> 点击勘误[issues](https://github.com/webVueBlog/learn-web/issues)，哪吒感谢大家的阅读

[[toc]]

## 函数声明与表达式

函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。

## 函数声明

```js
function foo() {}
```

上面的方法会在执行前被解析，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。

```js
foo(); // 正常运行，因为foo在代码运行前已经被创建
function foo() {}
```

## 函数赋值表达式

```js
var foo = function() {};
```

这个例子把一个匿名的函数赋值给变量foo.

```js
foo; // 'undefined'
foo(); // 出错：TypeError
var foo = function() {};
```

由于var定义了一个声明语句，对变量foo的解析是在代码运行之前，因此foo变量在代码运行时已经被定义过了。

但是由于赋值语句只在运行时执行，因此在相应代码执行之前，foo的值缺省为undefined。

## 命名函数的赋值表达式

另外一个特殊的情况是将命名函数赋值给一个变量。

```js
var foo = function bar() {
    bar(); // 正常运行
}

bar(); // 出错：ReferenceError
```

bar 函数声明外是不可见的，这是因为我们已经把函数赋值给了foo;然而在bar 内部依然可见。这是由于 JavaScript 的命名处理 所致，函数名在函数内总是可见的。

注意:在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析， 解析成两个函数 foo 和 bar

## this的工作原理

JavaScript有一套完全不同于其它语言的对 this 的处理机制。在五种不同情况下，this 指向的各不相同。

## 全局范围内

```js
this;
```

当在全部范围内使用 this, 它将会指向全局对象。

## 函数调用

```js
foo();
```

方法调用

```js
test.foo(); 
```

这个例子中，this 指向 test 对象。

## 调用构造函数

```js
new foo(); 
```

如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。

显式的设置 this

```js
function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // 数组将会被扩展，如下所示
foo.call(bar, 1, 2, 3); // 传递到foo的参数是：a = 1, b = 2, c = 3
```

当使用 `Function.prototype` 上的 `call` 或者 `apply` 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数。

因此函数调用的规则在上例中已经不适用了，在foo 函数内 this 被设置成了 bar。

## 常见误解

尽管大部分的情况都说的过去，不过第一个规则（这里指的应该是第二个规则，也就是直接调用函数时，this 指向全局对象） 被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。

```js
Foo.method = function() {
    function test() {
        // this 将会被设置为全局对象（浏览器环境中也就是 window 对象）
    }
    test();
}
```

一个常见的误解是 test 中的 this 将会指向 Foo 对象，实际上不是这样子的。

为了在 test 中获取对 Foo 对象的引用，我们需要在 method 函数内部创建一个局部变量指向 Foo 对象。

```js
Foo.method = function() {
    var that = this;
    function test() {
        // 使用 that 来指向 Foo 对象
    }
    test();
}
```

that 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 this 对象。 在 闭包 一节，我们可以看到 that 可以作为参数传递。

## 方法的赋值表达式

另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。

```js
var test = someObject.methodTest;
test();
```

上例中，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。

虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。

```js
function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
```

当 method 被调用时，this 将会指向 Bar 的实例对象。

## 闭包和引用

闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。

模拟私有变量

```js
function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
```

这里，Counter 函数返回两个闭包，函数 increment 和函数 get。 这两个函数都维持着 对外部作用域 Counter 的引用，因此总可以访问此作用域内定义的变量 count.

## 为什么不可以在外部访问私有变量

因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 count 变量。 唯一的途径就是通过那两个闭包。

```js
var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
```

上面的代码不会改变定义在 Counter 作用域中的 count 变量的值，因为 foo.hack 没有 定义在那个作用域内。它将会创建或者覆盖全局变量 count。

## 循环中的闭包

一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号

```js
for(var i = 0; i < 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
```

上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。

当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10.

为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。





